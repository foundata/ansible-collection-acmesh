# Setup: Manage basic resource installation/removal, such as packages or service users.

---

- name: "Setup | Default | Remove unwanted packages (e.g., to prevent conflicts or resolve incompatibilities)"
  ansible.builtin.package:
    name: "{{ __run_acmesh_packages_removal }}"
    state: "absent"
  when:
    - run_acmesh_state == 'present'
    - __run_acmesh__packages_removal is defined
    - (__run_acmesh__packages_removal | length) > 1


- name: "Setup | Default | Install needed packages"
  ansible.builtin.package:
    name: "{{ __run_acmesh_packages_install }}"
    state: "{% if run_acmesh_autoupgrade %}latest{% else %}present{% endif %}"
  when:
    - run_acmesh_state == 'present'
    - __run_acmesh_packages_install is defined
    - (__run_acmesh_packages_install | length) > 1


- name: "Setup | Default | Uninstall packages (in case of software removal)"
  ansible.builtin.package:
    name: "{{ run_acmesh_packages_uninstall }}"
    state: "absent"
  when:
    - run_acmesh_state == 'absent'
    - __run_acmesh_packages_uninstall is defined
    - (__run_acmesh_packages_uninstall | length) > 1


- name: "Setup | Default | Determine upstream version (latest)"
  # The shell module is used here, but this approach is NOT justified and
  # should be replaced in a future version of this role. Reasons:
  #
  # - ansible.builtin.uri provides comparable functionality to curl
  #   (so introducing a dependency on the target machine it not justified).
  # - community.general.json_query offers comparable capabilities as jq
  #   (so introducing a dependency on the target machine it not justified).
  #
  # After replacing the shell-based implementation, review the package
  # installation lists in /vars/*.yml to determine if any can be removed.
  ansible.builtin.shell:
    cmd: |
      __run_acmesh_version_upstream=''
      __run_acmesh_version_upstream="$(curl -s -L {{ __run_acme_sh_githubapi_release_latest_url }} | jq -r '.tag_name' | sed -e 's/^v//g')"
      if ! printf '%s' "${__run_acmesh_version_upstream}" | grep -E -q -e '^[[:digit:]\.]*$'
      then
        __run_acmesh_version_upstream=''
      fi
      printf '%s' "${__run_acmesh_version_upstream}"
      exit 0
    executable: "/usr/bin/bash" # this inline script was only tested with Bash yet, so hardcode the shell
  register: __run_acmesh_version_upstream_result
  ignore_errors: true
  changed_when: false


- name: "Setup | Default | Set latest upstream version as fact"
  ansible.builtin.set_fact:
    __run_acmesh_version_upstream: "{{ (__run_acmesh_version_upstream_result) | ternary(__run_acmesh_version_upstream_result['stdout'], false) }}"


- name: "Setup | Default | Display latest upstream version (if any, false means \"nothing detected\")"
  ansible.builtin.debug:
    var: __run_acmesh_version_upstream
    verbosity: 1


- name: "Setup | Default | Create service user"
  ansible.builtin.user:
    comment: "ACME client for issuing X.509 certs"
    create_home: true
    force: true
    # group: the (primary) group gets created automatically with the same GID as the UID when the parameter is omitted
    home: "{{ run_acmesh_cfg_home }}"
    # We first used "acme.sh" as username. However, a dot is not allowed in the
    # "User=" directive of systemd versions shipped with RHEL8 in October 2019, cf:
    # - https://github.com/systemd/systemd/issues/12754
    # - https://bugzilla.redhat.com/show_bug.cgi?id=1717603
    # To be on the safe side, we switched from "acme.sh" to "acmesh" as username.
    name: "{{ run_acmesh_user }}"
    password: "!" # locked / disabled password
    remove: true
    shell: "/sbin/nologin"
    state: "present"
    system: false
    update_password: "always"
    umask: "0027"


- name: "Setup | Default | Create an additional, non-primary group for service user"
  ansible.builtin.group:
    name: "{{ run_acmesh_group }}"
    state: "present"
    system: false
    force: false
  when:
    - run_acmesh_group != run_acmesh_user # only if different from the service user's primary group


- name: "Setup | Default | Add service user to a non-primary, additional group"
  ansible.builtin.user:
    name: "{{ run_acmesh_user }}"
    groups:
      - "{{ run_acmesh_group }}"
    append: false # remove from all groups (except the primary one)


- name: "Setup | Default | Create a temporary working directory"
  ansible.builtin.tempfile:
    state: "directory"
    suffix: "-acmesh"
  changed_when: false
  register: __run_acmesh_tempdir
  become_user: "{{ run_acmesh_user }}"
  when: not __run_acmesh_version_installed


- name: "Setup | Default | Display the temporary working directory's path"
  ansible.builtin.debug:
    var: __run_acmesh_tempdir
    verbosity: 2
  when: not __run_acmesh_version_installed


- name: "Setup | Default | git clone {{ __run_acme_sh_git_url }}"
  ansible.builtin.git:
    repo: "{{ __run_acme_sh_git_url }}"
    # on "master" branch as latest: https://github.com/acmesh-official/acme.sh/issues/1162
    version: "{{ (__run_acmesh_version_upstream) | ternary(__run_acmesh_version_upstream, __run_acme_sh_git_fallback_version_branch) }}"
    dest: "{{ __run_acmesh_tempdir['path'] }}"
    update: true
  become_user: "{{ run_acmesh_user }}"
  when: not __run_acmesh_version_installed


- name: "Setup | Default | Ensure that needed directories are existing"
  ansible.builtin.file:
    path: "{{ item }}"
    state: "directory"
    owner: "{{ run_acmesh_user }}"
    group: "{{ run_acmesh_group }}"
    mode: "u=rwx,g=rx,o=" # 0750
  loop:
    - "{{ run_acmesh_cfg_home }}"
    - "{{ run_acmesh_cfg_config_home }}"
    - "{{ run_acmesh_cfg_cert_home }}"


- name: "Setup | Default | Ensure that needed files are existing"
  ansible.builtin.copy:
    dest: "{{ item }}"
    content: ""
    force: false # do only create an empty file if not already existing
    owner: "{{ run_acmesh_user }}"
    group: "{{ run_acmesh_group }}"
    mode: "u=rw,g=r,o=" # 0640
  loop:
    - "{{ run_acmesh_cfg_logfile }}"


- name: "Setup | Default | Install acme.sh"
  # The command module is used here. This approach is justified:
  #
  # - No built-in Ansible module provides a direct way to interact with acme.sh.
  # - Inline templating allows for safe and efficient parameter handling,
  #   avoiding the need for multiple additional tasks with little to no benefit.
  #
  # Notes on the command itself:
  #
  # See the official documentation for a explanation of the parameters:
  # https://github.com/acmesh-official/acme.sh/wiki/Options-and-Params
  ansible.builtin.command:
    cmd:
      ./acme.sh
        --install
        --home "{{ run_acmesh_cfg_home }}"
        --config-home "{{ run_acmesh_cfg_config_home }}"
        --certhome "{{ run_acmesh_cfg_cert_home }}"
        --log "{{ run_acmesh_cfg_logfile }}"
        --log-level {{ run_acmesh_cfg_log_level }}
        --syslog {{ run_acmesh_cfg_syslog }}
        {{ '--auto-upgrade 1'
          if ((run_acmesh_autoupgrade is defined) and
              (run_acmesh_autoupgrade))
          else
          '--auto-upgrade 0' }}
        {{ '--accountemail "' ~ run_acmesh_cfg_accountemail ~ '"'
          if ((run_acmesh_cfg_accountemail is defined) and
              (run_acmesh_cfg_accountemail))
          else
          '' }}
  args:
    chdir: "{{ __run_acmesh_tempdir['path'] }}"
    creates:
      - "{{ run_acmesh_cfg_home }}/acme.sh"
      - "{{ run_acmesh_cfg_home }}/acme.sh.env"
  become_user: "{{ run_acmesh_user }}"
  when: not __run_acmesh_version_installed


- name: "Setup | Default | Upgrade acme.sh"
  # The command module is used here. This approach is justified:
  #
  # - No built-in Ansible module provides a direct way to interact with acme.sh.
  # - Inline templating allows for safe and efficient parameter handling,
  #   avoiding the need for multiple additional tasks with little to no benefit.
  #
  # Notes on the command itself:
  #
  # The --upgrade parameter alone would generally be sufficient. However, acme.sh
  # can update, modify, or correct configuration values during execution of most
  # subcommands. Setting the configuration parameters again ensures consistency and
  # does no harm. See the official documentation for a explanation of the parameters:
  # https://github.com/acmesh-official/acme.sh/wiki/Options-and-Params
  ansible.builtin.command:
    cmd:
      ./acme.sh
        --upgrade
        --home "{{ run_acmesh_cfg_home }}"
        --config-home "{{ run_acmesh_cfg_config_home }}"
        --certhome "{{ run_acmesh_cfg_cert_home }}"
        --log "{{ run_acmesh_cfg_logfile }}"
        --log-level {{ run_acmesh_cfg_log_level }}
        --syslog {{ run_acmesh_cfg_syslog }}
        {{ '--auto-upgrade 1'
          if ((run_acmesh_autoupgrade is defined) and
              (run_acmesh_autoupgrade))
          else
          '--auto-upgrade 0' }}
        {{ '--accountemail "' ~ run_acmesh_cfg_accountemail ~ '"'
          if ((run_acmesh_cfg_accountemail is defined) and
              (run_acmesh_cfg_accountemail))
          else
          '' }}
  args:
    chdir: "{{ run_acmesh_cfg_home }}"
  when:
    - __run_acmesh_version_installed
    - __run_acmesh_version_upstream
    - run_acmesh_autoupgrade is defined
    - run_acmesh_autoupgrade
    - __run_acmesh_version_installed is version(__run_acmesh_version_upstream, 'lt', version_type='semver')
  register: __run_acmesh_upgrade_result
  changed_when:
    - __run_acmesh_upgrade_result.rc == 0
    - "'Upgrade success' in __run_acmesh_upgrade_result.stdout"
  become_user: "{{ run_acmesh_user }}"


# update facts related to state of the local installation
- name: "Setup | Default | Determine installed version again"
  # The shell module is used here. This approach is justified:
  #
  # - No built-in Ansible module provides a direct way to retrieve the version.
  # - The script includes inline logic to handle potential edge cases (e.g.,
  #   non-numeric output) while only using standard tooling. A replacement
  #   would require many additional tasks with little to no benefit.
  # - Using ansible.builtin.stat and/or ansible.builtin.command for a safer exec
  #   environment would require additional tasks with little to no benefit.
  # - Security concerns are mitigated by strict path usage and input validation.
  ansible.builtin.shell:
    cmd: |
      __run_acmesh_version_installed=''
      if command -v '{{ run_acmesh_cfg_home }}/acme.sh' > /dev/null 2>&1
      then
        __run_acmesh_version_installed="$({{ run_acmesh_cfg_home }}/acme.sh --version | tail -1 | sed -e 's/^v//g')"
        if ! printf '%s' "${__run_acmesh_version_installed}" | grep -E -q -e '^[[:digit:]\.]*$'
        then
          __run_acmesh_version_installed=''
        fi
      fi
      printf '%s' "${__run_acmesh_version_installed}"
      exit 0
    executable: "/usr/bin/bash" # this inline script was only tested with Bash yet, so hardcode the shell
  register: __run_acmesh_version_installed_result
  ignore_errors: true
  changed_when: false


- name: "Setup | Default | Update / overwrite installed version fact"
  ansible.builtin.set_fact:
    __run_acmesh_version_installed: "{{ (__run_acmesh_version_installed_result) | ternary(__run_acmesh_version_installed_result['stdout'], false) }}"


- name: "Setup | Default | Display installed version (if any, false means \"not installed\")"
  ansible.builtin.debug:
    var: __run_acmesh_version_installed
    verbosity: 1


# By default, the .bashrc of the user who called the installer gets
# adapted for a proper acme.sh command alias with the needed options.
# We will make this alias globally valid by linking it plus removing
# the source-call from the user's .bashrc
- name: "Setup | Default | Symlink env file for profile.d"
  ansible.builtin.file:
    src: "{{ run_acmesh_cfg_home }}/acme.sh.env"
    dest: "/etc/profile.d/acme.sh.env.sh"
    state: "link"


- name: "Setup | Default | Remove redundant env file sourcing from the user's .bashrc"
  ansible.builtin.lineinfile:
    path: "~/.bashrc"
    state: "absent"
    regexp: "^\\. \"{{ run_acmesh_cfg_home }}/acme.sh.env\"$"
  become_user: "{{ run_acmesh_user }}"


- name: "Setup | Default | Set permissions of env file"
  ansible.builtin.file:
    path: "{{ item }}"
    owner: "{{ run_acmesh_user }}"
    group: "{{ run_acmesh_group }}"
    mode: "u=rw,g=r,o=r" # 0644
  loop:
    - "{{ run_acmesh_cfg_home }}/acme.sh.env"


# This is an additional safeguard (block group member's too) as the config
# file usually contains DNS provider credentials.
- name: "Setup | Default | Restrict permissions of account file"
  ansible.builtin.file:
    path: "{{ item }}"
    owner: "{{ run_acmesh_user }}"
    group: "{{ run_acmesh_group }}"
    mode: "u=rw,g=,o=" # 0600
  loop:
    - "{{ run_acmesh_cfg_config_home }}/account.conf"


# TODO: To be removed in future versions of this role once all acme.sh versions ≤ 3.0.6
# are guaranteed to be absent in all environments, or by mid-2025—whichever comes first.
# https://github.com/acmesh-official/acme.sh/issues/4763#issuecomment-1695832047
- name: "Setup | Default | Temporary workaround for issue 4763 (dns_inwx broken in versions <= 3.0.6)"
  ansible.builtin.lineinfile:
    path: "{{ run_acmesh_cfg_home }}/dnsapi/dns_inwx.sh"
    regexp: '^([\t ]+?INWX_Cookie.+)grep \"\^(.+)$'
    line: '\1grep -i "^\2'
    backrefs: true
  when:
    - __run_acmesh_version_installed
    - __run_acmesh_version_installed is version('3.0.6', 'le', version_type='semver')


# These tasks for copying existing certificates can be useful in non-production
# environments during development to avoid hitting CA rate limits or encountering
# similar restrictions.
- name: "Setup | Default | Check for pre-seeded cert dirs (RSA) at local source"
  ansible.builtin.stat:
    path: "{{ playbook_dir }}/files/acme.sh/certhome/{{ item }}"
    get_checksum: false
    get_mime: false
    get_attributes: false
  register: __run_acmesh_local_preseed_rsa_result
  loop: "{{ run_acmesh_certs | selectattr('domains', 'defined') | map(attribute='domains') | flatten | selectattr('name', 'defined') | map(attribute='name') | unique }}"
  become: false
  delegate_to: "localhost"
  when: run_acmesh_certs is defined


- name: "Setup | Default | show data about pre-seeded cert dirs (RSA) at local source"
  ansible.builtin.debug:
    var: __run_acmesh_local_preseed_rsa_result
    verbosity: 3
  when:
    - run_acmesh_certs is defined
    - __run_acmesh_local_preseed_rsa_result is defined


- name: "Setup | Default | pre-seed already issued certs (RSA) from local source (if any)"
  ansible.builtin.copy:
    src: "{{ item['stat']['path'] }}"
    dest: "{{ run_acmesh_cfg_cert_home }}"
    owner: "{{ run_acmesh_user }}"
    group: "{{ run_acmesh_group }}"
    directory_mode: "u=rwx,g=rx,o=" # 0750
    mode: "u=rw,g=rw,o=" # 0640
    remote_src: false
    decrypt: true
    force: false # do not overwrite anything if already existing on target
  when:
    - __run_acmesh_version_installed
    - run_acmesh_certs is defined
    - item['stat'] is defined
    - item['stat']['exists']
    - item['stat']['path'] is defined
  loop: "{{ __run_acmesh_local_preseed_rsa_result['results'] }}"


- name: "Setup | Default | check for pre-seeded cert dirs (ECC) at local source"
  ansible.builtin.stat:
    path: "{{ playbook_dir }}/files/acme.sh/certhome/{{ item }}_ecc"
    get_checksum: false
    get_mime: false
    get_attributes: false
  register: __run_acmesh_local_preseed_ecc_result
  loop: "{{ run_acmesh_certs | selectattr('domains', 'defined') | map(attribute='domains') | flatten | selectattr('name', 'defined') | map(attribute='name') | unique }}"
  become: false
  delegate_to: "localhost"
  when: run_acmesh_certs is defined


- name: "Setup | Default | show data about pre-seeded cert dirs (ECC) at local source"
  ansible.builtin.debug:
    var: __run_acmesh_local_preseed_ecc_result
    verbosity: 3
  when:
    - run_acmesh_certs is defined
    - __run_acmesh_local_preseed_ecc_result is defined


- name: "Setup | Default | pre-seed already issued certs (ECC) from local source (if any)"
  ansible.builtin.copy:
    src: "{{ item['stat']['path'] }}"
    dest: "{{ run_acmesh_cfg_cert_home }}"
    owner: "{{ run_acmesh_user }}"
    group: "{{ run_acmesh_group }}"
    directory_mode: "u=rwx,g=rx,o=" # 0750
    mode: "u=rw,g=r,o=" # 0640
    remote_src: false
    decrypt: true
    force: false # do not overwrite anything if already existing on target
  when:
    - __run_acmesh_version_installed
    - run_acmesh_certs is defined
    - item['stat'] is defined
    - item['stat']['exists']
    - item['stat']['path'] is defined
  loop: "{{ __run_acmesh_local_preseed_ecc_result['results'] }}"


- name: "Setup | Default | issue certificate(s)"
  # The command module is used here. This approach is justified:
  #
  # - No built-in Ansible module provides a direct way to interact with acme.sh.
  # - Inline templating allows for safe and efficient parameter handling,
  #   avoiding the need for multiple additional tasks with little to no benefit.
  ansible.builtin.command:
    cmd:
      ./acme.sh
        --issue
        --config-home "{{ run_acmesh_cfg_config_home }}"
        --certhome "{{ run_acmesh_cfg_cert_home }}"
        {% for item_domain in item['domains'] %}
          --domain "{{ item_domain['name'] }}"
          {{ '--dns "' ~ item_domain['challenge']['dns_provider'] ~ '"'
              if ((item_domain['challenge'] is defined) and
                  (item_domain['challenge']['type'] is defined) and
                  (item_domain['challenge']['type'] == 'dns') and
                  (item_domain['challenge']['dns_provider'] is defined) and
                  (item_domain['challenge']['dns_provider']))
              else
              '' }}
          {{ '--domain-alias "' ~ item_domain['challenge']['domain_alias'] ~ '"'
              if ((item_domain['challenge']['domain_alias'] is defined) and
                  (item_domain['challenge']['domain_alias']))
              else
              '' }}
          {{ '--challenge-alias "' ~ item_domain['challenge']['challenge_alias'] ~ '"'
              if ((item_domain['challenge']['challenge_alias'] is defined) and
                  (item_domain['challenge']['challenge_alias']))
              else
              '' }}
          {{ '--webroot "' ~ item_domain['challenge']['webroot'] ~ '"'
              if ((item_domain['challenge'] is defined) and
                  (item_domain['challenge']['type'] is defined) and
                  (item_domain['challenge']['type'] == 'webroot') and
                  (item_domain['challenge']['webroot'] is defined) and
                  (item_domain['challenge']['webroot']))
              else
              '' }}
          {{ '--standalone'
              if ((item_domain['challenge'] is defined) and
                  (item_domain['challenge']['type'] is defined) and
                  (item_domain['challenge']['type'] == 'standalone'))
              else
              '' }}
          {{ '--httpport ' ~ item_domain['challenge']['httpport']
              if ((item_domain['challenge']['httpport'] is defined) and
                  (item_domain['challenge']['httpport']))
              else
              '' }}
          {{ '--alpn'
              if ((item_domain['challenge'] is defined) and
                  (item_domain['challenge']['type'] is defined) and
                  (item_domain['challenge']['type'] == 'alpn'))
              else
              '' }}
          {{ '--tlsport ' ~ item_domain['challenge']['tlsport']
              if ((item_domain['challenge']['tlsport'] is defined) and
                  (item_domain['challenge']['tlsport']))
              else
              '' }}
        {% endfor %}
        {{ '--force'
            if ((item['force'] is defined) and
                (item['force']))
            else
            '' }}
        {{ '--debug'
            if ((item['debug'] is defined) and
                (item['debug']))
            else
            '' }}
        {{ '--dnssleep ' ~ (item['dnssleep'] | int)
            if (item['dnssleep'] is defined)
            else
            '' }}
        {{ '--pre-hook "' ~ item['pre_hook'] ~ '"'
            if ((item['pre_hook'] is defined) and
                (item['pre_hook']))
            else
            '' }}
        {{ '--post-hook "' ~ item['post_hook'] ~ '"'
            if ((item['post_hook'] is defined) and
                (item['post_hook']))
            else
            '' }}
        {{ '--renew-hook "' ~ item['renew_hook'] ~ '"'
            if ((item['renew_hook'] is defined) and
                (item['renew_hook']))
            else
            '' }}
        {{ '--server "' ~ item['server'] ~ '"'
            if ((item['server'] is defined) and
                (item['server']))
            else
            '--server letsencrypt' }}
        {{  item['extra_flags']
            if (item['extra_flags'] is defined)
            else
            '' }}
  args:
    chdir: "{{ run_acmesh_cfg_home }}"
  loop: "{{ run_acmesh_certs }}"
  environment: "{{ run_acmesh_environment | default(omit) }}"
  register: __run_acmesh_issue_result
  changed_when:
    - __run_acmesh_issue_result.rc == 0
    - "'Cert success' in __run_acmesh_issue_result.stdout"
  failed_when: >
    (run_acmesh_certs is not defined) or
    (__run_acmesh_issue_result.rc != 0 and 'Domains not changed' not in __run_acmesh_issue_result.stdout)
  become_user: "{{ run_acmesh_user }}"
  when:
    - __run_acmesh_version_installed
    - run_acmesh_certs is defined


- name: "Setup | Default | create target directories for certificate installation(s) (based on data for --ca-file, if any)"
  ansible.builtin.file:
    path: "{{ item['ca_file'] | dirname }}"
    state: "directory"
    group: "acmesh"
    owner: "acmesh"
    mode: "u=rwx,g=rx,o=" # 0750
  loop: "{{ run_acmesh_certs | selectattr('install', 'defined') | map(attribute='install') | selectattr('ca_file', 'defined') | list }}"
  when:
    - __run_acmesh_version_installed
    - run_acmesh_certs is defined


- name: "Setup | Default | create target directories for certificate installation(s) (based on data for --cert-file, if any)"
  ansible.builtin.file:
    path: "{{ item['cert_file'] | dirname }}"
    state: "directory"
    group: "acmesh"
    owner: "acmesh"
    mode: "u=rwx,g=rx,o=" # 0750
  loop: "{{ run_acmesh_certs | selectattr('install', 'defined') | map(attribute='install') | selectattr('cert_file', 'defined') | list }}"
  when:
    - __run_acmesh_version_installed
    - run_acmesh_certs is defined


- name: "Setup | Default | create target directories for certificate installation(s) (based on data for --fullcain-file, if any)"
  ansible.builtin.file:
    path: "{{ item['fullcain_file'] | dirname }}"
    state: "directory"
    group: "acmesh"
    owner: "acmesh"
    mode: "u=rwx,g=rx,o=" # 0750
  loop: "{{ run_acmesh_certs | selectattr('install', 'defined') | map(attribute='install') | selectattr('fullcain_file', 'defined') | list }}"
  when:
    - __run_acmesh_version_installed
    - run_acmesh_certs is defined


- name: "Setup | Default | create target directories for certificate installation(s) (based on data for --key-file, if any)"
  ansible.builtin.file:
    path: "{{ item['key_file'] | dirname }}"
    state: "directory"
    group: "acmesh"
    owner: "acmesh"
    mode: "u=rwx,g=rx,o=" # 0750
  loop: "{{ run_acmesh_certs | selectattr('install', 'defined') | map(attribute='install') | selectattr('key_file', 'defined') | list }}"
  when:
    - __run_acmesh_version_installed
    - run_acmesh_certs is defined


- name: "Setup | Default | install certificate(s)"
  # The command module is used here. This approach is justified:
  #
  # - No built-in Ansible module provides a direct way to interact with acme.sh.
  # - Inline templating allows for safe and efficient parameter handling,
  #   avoiding the need for multiple additional tasks with little to no benefit.
  ansible.builtin.command:
    cmd:
      ./acme.sh
        --install-cert
        --config-home "{{ run_acmesh_cfg_config_home }}"
        --certhome "{{ run_acmesh_cfg_cert_home }}"
        --domain "{{ item['domains'][0]['name'] }}"
        {{ '--ca-file "' ~ item['install']['ca_file'] ~ '"'
            if ((item['install']['ca_file'] is defined) and
                (item['install']['ca_file']))
            else
            '' }}
        {{ '--cert-file "' ~ item['install']['cert_file'] ~ '"'
            if ((item['install']['cert_file'] is defined) and
                (item['install']['cert_file']))
            else
            '' }}
        {{ '--fullchain-file "' ~ item['install']['fullcain_file'] ~ '"'
            if ((item['install']['fullcain_file'] is defined) and
                (item['install']['fullcain_file']))
            else
            '' }}
        {{ '--key-file "' ~ item['install']['key_file'] ~ '"'
            if ((item['install']['key_file'] is defined) and
                (item['install']['key_file']))
            else
            '' }}
        {{ '--reloadcmd "' ~ item['install']['reloadcmd'] ~ '"'
            if ((item['install']['reloadcmd'] is defined) and
                (item['install']['reloadcmd']))
            else
            '' }}
  args:
    chdir: "{{ run_acmesh_cfg_home }}"
  loop: "{{ run_acmesh_certs }}"
  environment: "{{ run_acmesh_environment | default(omit) }}"
  register: __run_acmesh_install_result
  changed_when:
    - __run_acmesh_install_result.rc == 0
    - "'Cert success' in __run_acmesh_install_result.stdout"
  # Errors from --reloadcmd are ignored to avoid chicken-and-egg issues. These
  # errors typically occur when services required for reloading are not yet
  # running because they depend on valid certificates. Services managed by
  # Ansible that rely on these certificates should trigger relevant errors later
  # if issues persist.
  failed_when: >
    (run_acmesh_certs is not defined) or
    (__run_acmesh_install_result.rc != 0 and 'Installing' not in __run_acmesh_install_result.stdout) or
    (__run_acmesh_install_result.rc != 0 and ((__run_acmesh_install_result.stderr_lines | length) > 0) and 'Reload error' not in __run_acmesh_install_result.stderr)
  become_user: "root" # run as root and specify --config-home {{ run_acmesh_cfg_config_home }} to be able to install the files whereever needed
  when:
    - __run_acmesh_version_installed
    - run_acmesh_certs is defined


- name: "Setup | Default | gather certificate information"
  ansible.builtin.command:
    cmd: "./acme.sh --list --certhome {{ run_acmesh_cfg_cert_home }}"
  args:
    chdir: "{{ run_acmesh_cfg_home }}"
  changed_when: false
  register: __run_acmesh_list_domains_result
  become_user: "{{ run_acmesh_user }}"
  when:
    - __run_acmesh_version_installed
    - ansible_verbosity > 3


- name: "Setup | Default | show certificate information"
  ansible.builtin.debug:
    msg: "{{ __run_acmesh_list_domains_result['stdout_lines'] }}"
    verbosity: 3
  when:
    - __run_acmesh_version_installed
    - __run_acmesh_list_domains_result
    - ansible_verbosity > 3
